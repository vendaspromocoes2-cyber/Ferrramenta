# Execution instructions:
# blender --background --python src/image_converter/image_to_fbx_ia.py -- --image_path /path/to/your/image.jpg --output_folder /path/to/your/output/folder

import argparse
import bpy
import os
import sys

def get_args():
    """
    Parses and returns the command-line arguments.
    """
    # Blender's Python interpreter does not strip the initial arguments
    argv = sys.argv
    if "--" in argv:
        argv = argv[argv.index("--") + 1:]  # get all args after --
    else:
        argv = []

    parser = argparse.ArgumentParser(description="Converts a 2D image to an optimized FBX file.")
    parser.add_argument("--image_path", type=str, required=True, help="Full path to the input 2D image file.")
    parser.add_argument("--output_folder", type=str, required=True, help="Destination folder to save the FBX and textures.")
    parser.add_argument("--poly_count", type=int, default=25000, help="Maximum number of polygons for the optimized output model.")

    return parser.parse_args(argv)

# ==================================================================================================
# IA Placeholder Function
# ==================================================================================================
def generate_3d_from_image(image_path, temp_output_dir):
    """
    **Placeholder Function**
    This function simulates the output of a Monocular 3D Reconstruction AI model.
    In a real implementation, this function would call an AI API (like TripoSR)
    to generate a 3D model from the input image.

    For now, it creates dummy output files to allow the rest of the pipeline to work.

    Args:
        image_path (str): The path to the input image. (Not used in this placeholder)
        temp_output_dir (str): The directory to save the temporary files.

    Returns:
        tuple: A tuple containing the paths to the generated mesh and texture files.
    """
    print("--- SIMULATING 3D MODEL GENERATION FROM IMAGE ---")

    # Ensure the temporary directory exists
    os.makedirs(temp_output_dir, exist_ok=True)

    # Define paths for the dummy files
    mesh_path = os.path.join(temp_output_dir, "high_res_mesh.obj")
    texture_path = os.path.join(temp_output_dir, "base_texture.png")

    # Create a dummy OBJ file (a simple cube)
    with open(mesh_path, 'w') as f:
        f.write("# Dummy OBJ file generated by placeholder function\n")
        f.write("v 1.0 1.0 -1.0\n")
        f.write("v 1.0 -1.0 -1.0\n")
        f.write("v 1.0 1.0 1.0\n")
        f.write("v 1.0 -1.0 1.0\n")
        f.write("v -1.0 1.0 -1.0\n")
        f.write("v -1.0 -1.0 -1.0\n")
        f.write("v -1.0 1.0 1.0\n")
        f.write("v -1.0 -1.0 1.0\n")
        f.write("f 1 2 4 3\n")
        f.write("f 3 4 8 7\n")
        f.write("f 7 8 6 5\n")
        f.write("f 5 6 2 1\n")
        f.write("f 1 3 7 5\n")
        f.write("f 2 4 8 6\n")

    # Create a dummy PNG file (just an empty file)
    # In a real scenario, this would be the texture map generated by the AI.
    with open(texture_path, 'w') as f:
        pass # Create an empty file

    print(f"   - Dummy mesh created at: {mesh_path}")
    print(f"   - Dummy texture created at: {texture_path}")
    print("--- SIMULATION COMPLETE ---")

    return mesh_path, texture_path

# ==================================================================================================
# Blender Logic for Optimization and Export
# ==================================================================================================
def optimize_and_export_fbx(mesh_path, texture_path, output_folder, poly_count):
    """
    Optimizes a high-resolution mesh and bakes its texture to a low-resolution version,
    then exports it as an FBX file suitable for Unreal Engine.
    """
    print("--- STARTING BLENDER OPTIMIZATION AND EXPORT ---")

    # --- 1. Scene Cleanup ---
    print("   - Cleaning up the scene...")
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()

    # --- 2. Import High-Res Mesh ---
    print(f"   - Importing high-res mesh: {mesh_path}")
    bpy.ops.import_scene.obj(filepath=mesh_path)
    high_res_obj = bpy.context.selected_objects[0]
    bpy.context.view_layer.objects.active = high_res_obj

    # --- 3. Create Low-Res Duplicate and Decimate ---
    print(f"   - Creating low-poly version with target face count: {poly_count}")
    bpy.ops.object.duplicate()
    low_res_obj = bpy.context.selected_objects[0]
    low_res_obj.name = "low_poly_mesh"

    decimate_modifier = low_res_obj.modifiers.new(name="Decimate", type='DECIMATE')

    # Calculate the ratio based on the desired face count
    if len(high_res_obj.data.polygons) > 0:
        ratio = poly_count / len(high_res_obj.data.polygons)
        decimate_modifier.ratio = max(0.0001, min(1.0, ratio)) # Clamp ratio
    else:
        decimate_modifier.ratio = 1.0 # No faces to decimate

    bpy.ops.object.modifier_apply(modifier=decimate_modifier.name)

    # --- 4. UV Unwrapping the Low-Poly Mesh ---
    print("   - UV unwrapping the low-poly mesh...")
    bpy.ops.object.select_all(action='DESELECT')
    low_res_obj.select_set(True)
    bpy.context.view_layer.objects.active = low_res_obj
    bpy.ops.object.mode_set(mode='EDIT')
    bpy.ops.mesh.select_all(action='SELECT')
    bpy.ops.uv.smart_project()
    bpy.ops.object.mode_set(mode='OBJECT')

    # --- 5. Material Setup and Texture Baking ---
    print("   - Setting up materials for texture baking...")

    # Create a new material for the low-poly object
    low_poly_mat = bpy.data.materials.new(name="LowPolyMaterial")
    low_res_obj.data.materials.append(low_poly_mat)
    low_poly_mat.use_nodes = True
    bsdf = low_poly_mat.node_tree.nodes.get('Principled BSDF')

    # Create a new image texture node for the baked texture
    baked_texture_node = low_poly_mat.node_tree.nodes.new('ShaderNodeTexImage')
    baked_texture_node.location = bsdf.location - (400, 0)

    # Create the image to bake to
    baked_image_name = "final_albedo"
    baked_image = bpy.data.images.new(baked_image_name, 1024, 1024)
    baked_texture_node.image = baked_image
    low_poly_mat.node_tree.links.new(bsdf.inputs['Base Color'], baked_texture_node.outputs['Color'])
    low_poly_mat.node_tree.nodes.active = baked_texture_node # Make it the active node for baking

    # Setup high-res material
    high_res_mat = bpy.data.materials.new(name="HighPolyMaterial")
    high_res_obj.data.materials.append(high_res_mat)
    high_res_mat.use_nodes = True
    high_res_bsdf = high_res_mat.node_tree.nodes.get('Principled BSDF')
    high_res_texture_node = high_res_mat.node_tree.nodes.new('ShaderNodeTexImage')

    # Load the original texture
    try:
        original_texture = bpy.data.images.load(texture_path)
        high_res_texture_node.image = original_texture
    except Exception as e:
        print(f"     - Warning: Could not load texture {texture_path}. Baking will result in a blank texture. Error: {e}")

    high_res_mat.node_tree.links.new(high_res_bsdf.inputs['Base Color'], high_res_texture_node.outputs['Color'])

    # --- 6. Bake ---
    print("   - Baking texture from high-poly to low-poly...")
    bpy.context.scene.render.engine = 'CYCLES'
    bpy.context.scene.cycles.bake_type = 'DIFFUSE'
    bpy.context.scene.render.bake.use_pass_direct = False
    bpy.context.scene.render.bake.use_pass_indirect = False

    # Select high-res then low-res
    bpy.ops.object.select_all(action='DESELECT')
    high_res_obj.select_set(True)
    low_res_obj.select_set(True)
    bpy.context.view_layer.objects.active = low_res_obj

    bpy.ops.object.bake(type='DIFFUSE', save_mode='INTERNAL')

    # Save the baked image
    baked_image_path = os.path.join(output_folder, "final_albedo.png")
    baked_image.filepath_raw = baked_image_path
    baked_image.file_format = 'PNG'
    baked_image.save()
    print(f"   - Baked texture saved to: {baked_image_path}")

    # --- 7. Export FBX ---
    print("   - Exporting final FBX model...")
    fbx_path = os.path.join(output_folder, "optimized_model.fbx")

    # Select only the low-poly object for export
    bpy.ops.object.select_all(action='DESELECT')
    low_res_obj.select_set(True)

    bpy.ops.export_scene.fbx(
        filepath=fbx_path,
        use_selection=True,
        axis_forward='-Z',
        axis_up='Y',
        apply_scale_options='FBX_SCALE_ALL',
        object_types={'MESH'},
        path_mode='COPY',
        embed_textures=True
    )
    print(f"   - FBX model saved to: {fbx_path}")
    print("--- BLENDER SCRIPT FINISHED ---")


if __name__ == "__main__":
    args = get_args()

    # Create a temporary directory inside the output folder for intermediate files
    temp_dir = os.path.join(args.output_folder, "temp")

    # Call the placeholder function to get the paths to the generated files
    mesh_file, texture_file = generate_3d_from_image(args.image_path, temp_dir)

    # Call the Blender function to optimize and export the model
    optimize_and_export_fbx(mesh_file, texture_file, args.output_folder, args.poly_count)
